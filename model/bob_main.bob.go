// Code generated by BobGen psql v0.0.0-20250612114253-14d7148b83cb. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package model

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"hash/maphash"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/clause"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/orm"
)

var TableNames = struct {
	Environments          string
	Migrations            string
	PGStatStatements      string
	PGStatStatementsInfos string
	PrivateKeys           string
	Projects              string
	Servers               string
	Sessions              string
	Users                 string
}{
	Environments:          "environments",
	Migrations:            "migrations",
	PGStatStatements:      "pg_stat_statements",
	PGStatStatementsInfos: "pg_stat_statements_info",
	PrivateKeys:           "private_keys",
	Projects:              "projects",
	Servers:               "servers",
	Sessions:              "sessions",
	Users:                 "users",
}

var ColumnNames = struct {
	Environments          environmentColumnNames
	Migrations            migrationColumnNames
	PGStatStatements      pgStatStatementColumnNames
	PGStatStatementsInfos pgStatStatementsInfoColumnNames
	PrivateKeys           privateKeyColumnNames
	Projects              projectColumnNames
	Servers               serverColumnNames
	Sessions              sessionColumnNames
	Users                 userColumnNames
}{
	Environments: environmentColumnNames{
		ID:        "id",
		Name:      "name",
		ProjectID: "project_id",
		CreatedAt: "created_at",
		UpdatedAt: "updated_at",
	},
	Migrations: migrationColumnNames{
		ID:        "id",
		AppliedAt: "applied_at",
	},
	PGStatStatements: pgStatStatementColumnNames{
		Userid:               "userid",
		Dbid:                 "dbid",
		Toplevel:             "toplevel",
		Queryid:              "queryid",
		Query:                "query",
		Plans:                "plans",
		TotalPlanTime:        "total_plan_time",
		MinPlanTime:          "min_plan_time",
		MaxPlanTime:          "max_plan_time",
		MeanPlanTime:         "mean_plan_time",
		StddevPlanTime:       "stddev_plan_time",
		Calls:                "calls",
		TotalExecTime:        "total_exec_time",
		MinExecTime:          "min_exec_time",
		MaxExecTime:          "max_exec_time",
		MeanExecTime:         "mean_exec_time",
		StddevExecTime:       "stddev_exec_time",
		Rows:                 "rows",
		SharedBLKSHit:        "shared_blks_hit",
		SharedBLKSRead:       "shared_blks_read",
		SharedBLKSDirtied:    "shared_blks_dirtied",
		SharedBLKSWritten:    "shared_blks_written",
		LocalBLKSHit:         "local_blks_hit",
		LocalBLKSRead:        "local_blks_read",
		LocalBLKSDirtied:     "local_blks_dirtied",
		LocalBLKSWritten:     "local_blks_written",
		TempBLKSRead:         "temp_blks_read",
		TempBLKSWritten:      "temp_blks_written",
		SharedBLKReadTime:    "shared_blk_read_time",
		SharedBLKWriteTime:   "shared_blk_write_time",
		LocalBLKReadTime:     "local_blk_read_time",
		LocalBLKWriteTime:    "local_blk_write_time",
		TempBLKReadTime:      "temp_blk_read_time",
		TempBLKWriteTime:     "temp_blk_write_time",
		WalRecords:           "wal_records",
		WalFpi:               "wal_fpi",
		WalBytes:             "wal_bytes",
		JitFunctions:         "jit_functions",
		JitGenerationTime:    "jit_generation_time",
		JitInliningCount:     "jit_inlining_count",
		JitInliningTime:      "jit_inlining_time",
		JitOptimizationCount: "jit_optimization_count",
		JitOptimizationTime:  "jit_optimization_time",
		JitEmissionCount:     "jit_emission_count",
		JitEmissionTime:      "jit_emission_time",
		JitDeformCount:       "jit_deform_count",
		JitDeformTime:        "jit_deform_time",
		StatsSince:           "stats_since",
		MinmaxStatsSince:     "minmax_stats_since",
	},
	PGStatStatementsInfos: pgStatStatementsInfoColumnNames{
		Dealloc:    "dealloc",
		StatsReset: "stats_reset",
	},
	PrivateKeys: privateKeyColumnNames{
		ID:           "id",
		Name:         "name",
		UserID:       "user_id",
		Description:  "description",
		PrivateKey:   "private_key",
		IsGitRelated: "is_git_related",
		CreatedAt:    "created_at",
		UpdatedAt:    "updated_at",
	},
	Projects: projectColumnNames{
		ID:          "id",
		Name:        "name",
		UserID:      "user_id",
		Description: "description",
		CreatedAt:   "created_at",
		UpdatedAt:   "updated_at",
	},
	Servers: serverColumnNames{
		ID:           "id",
		Name:         "name",
		UserID:       "user_id",
		Description:  "description",
		IP:           "ip",
		Port:         "port",
		Username:     "username",
		PrivateKeyID: "private_key_id",
		CreatedAt:    "created_at",
		UpdatedAt:    "updated_at",
	},
	Sessions: sessionColumnNames{
		ID:        "id",
		UserID:    "user_id",
		IPAddress: "ip_address",
		UserAgent: "user_agent",
		ExpiredAt: "expired_at",
	},
	Users: userColumnNames{
		ID:        "id",
		Name:      "name",
		Email:     "email",
		Password:  "password",
		CreatedAt: "created_at",
		UpdatedAt: "updated_at",
	},
}

var (
	SelectWhere     = Where[*dialect.SelectQuery]()
	UpdateWhere     = Where[*dialect.UpdateQuery]()
	DeleteWhere     = Where[*dialect.DeleteQuery]()
	OnConflictWhere = Where[*clause.ConflictClause]() // Used in ON CONFLICT DO UPDATE
)

func Where[Q psql.Filterable]() struct {
	Environments          environmentWhere[Q]
	Migrations            migrationWhere[Q]
	PGStatStatements      pgStatStatementWhere[Q]
	PGStatStatementsInfos pgStatStatementsInfoWhere[Q]
	PrivateKeys           privateKeyWhere[Q]
	Projects              projectWhere[Q]
	Servers               serverWhere[Q]
	Sessions              sessionWhere[Q]
	Users                 userWhere[Q]
} {
	return struct {
		Environments          environmentWhere[Q]
		Migrations            migrationWhere[Q]
		PGStatStatements      pgStatStatementWhere[Q]
		PGStatStatementsInfos pgStatStatementsInfoWhere[Q]
		PrivateKeys           privateKeyWhere[Q]
		Projects              projectWhere[Q]
		Servers               serverWhere[Q]
		Sessions              sessionWhere[Q]
		Users                 userWhere[Q]
	}{
		Environments:          buildEnvironmentWhere[Q](EnvironmentColumns),
		Migrations:            buildMigrationWhere[Q](MigrationColumns),
		PGStatStatements:      buildPGStatStatementWhere[Q](PGStatStatementColumns),
		PGStatStatementsInfos: buildPGStatStatementsInfoWhere[Q](PGStatStatementsInfoColumns),
		PrivateKeys:           buildPrivateKeyWhere[Q](PrivateKeyColumns),
		Projects:              buildProjectWhere[Q](ProjectColumns),
		Servers:               buildServerWhere[Q](ServerColumns),
		Sessions:              buildSessionWhere[Q](SessionColumns),
		Users:                 buildUserWhere[Q](UserColumns),
	}
}

var Preload = getPreloaders()

type preloaders struct {
	Environment environmentPreloader
	PrivateKey  privateKeyPreloader
	Project     projectPreloader
	Server      serverPreloader
	Session     sessionPreloader
	User        userPreloader
}

func getPreloaders() preloaders {
	return preloaders{
		Environment: buildEnvironmentPreloader(),
		PrivateKey:  buildPrivateKeyPreloader(),
		Project:     buildProjectPreloader(),
		Server:      buildServerPreloader(),
		Session:     buildSessionPreloader(),
		User:        buildUserPreloader(),
	}
}

var (
	SelectThenLoad = getThenLoaders[*dialect.SelectQuery]()
	InsertThenLoad = getThenLoaders[*dialect.InsertQuery]()
	UpdateThenLoad = getThenLoaders[*dialect.UpdateQuery]()
)

type thenLoaders[Q orm.Loadable] struct {
	Environment environmentThenLoader[Q]
	PrivateKey  privateKeyThenLoader[Q]
	Project     projectThenLoader[Q]
	Server      serverThenLoader[Q]
	Session     sessionThenLoader[Q]
	User        userThenLoader[Q]
}

func getThenLoaders[Q orm.Loadable]() thenLoaders[Q] {
	return thenLoaders[Q]{
		Environment: buildEnvironmentThenLoader[Q](),
		PrivateKey:  buildPrivateKeyThenLoader[Q](),
		Project:     buildProjectThenLoader[Q](),
		Server:      buildServerThenLoader[Q](),
		Session:     buildSessionThenLoader[Q](),
		User:        buildUserThenLoader[Q](),
	}
}

func thenLoadBuilder[Q orm.Loadable, T any](name string, f func(context.Context, bob.Executor, T, ...bob.Mod[*dialect.SelectQuery]) error) func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q] {
	return func(queryMods ...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q] {
		return func(ctx context.Context, exec bob.Executor, retrieved any) error {
			loader, isLoader := retrieved.(T)
			if !isLoader {
				return fmt.Errorf("object %T cannot load %q", retrieved, name)
			}

			err := f(ctx, exec, loader, queryMods...)

			// Don't cause an issue due to missing relationships
			if errors.Is(err, sql.ErrNoRows) {
				return nil
			}

			return err
		}
	}
}

var (
	SelectJoins = getJoins[*dialect.SelectQuery]()
	UpdateJoins = getJoins[*dialect.UpdateQuery]()
	DeleteJoins = getJoins[*dialect.DeleteQuery]()
)

type joinSet[Q interface{ aliasedAs(string) Q }] struct {
	InnerJoin Q
	LeftJoin  Q
	RightJoin Q
}

func (j joinSet[Q]) AliasedAs(alias string) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: j.InnerJoin.aliasedAs(alias),
		LeftJoin:  j.LeftJoin.aliasedAs(alias),
		RightJoin: j.RightJoin.aliasedAs(alias),
	}
}

type joins[Q dialect.Joinable] struct {
	Environments joinSet[environmentJoins[Q]]
	PrivateKeys  joinSet[privateKeyJoins[Q]]
	Projects     joinSet[projectJoins[Q]]
	Servers      joinSet[serverJoins[Q]]
	Sessions     joinSet[sessionJoins[Q]]
	Users        joinSet[userJoins[Q]]
}

func buildJoinSet[Q interface{ aliasedAs(string) Q }, C any, F func(C, string) Q](c C, f F) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: f(c, clause.InnerJoin),
		LeftJoin:  f(c, clause.LeftJoin),
		RightJoin: f(c, clause.RightJoin),
	}
}

func getJoins[Q dialect.Joinable]() joins[Q] {
	return joins[Q]{
		Environments: buildJoinSet[environmentJoins[Q]](EnvironmentColumns, buildEnvironmentJoins),
		PrivateKeys:  buildJoinSet[privateKeyJoins[Q]](PrivateKeyColumns, buildPrivateKeyJoins),
		Projects:     buildJoinSet[projectJoins[Q]](ProjectColumns, buildProjectJoins),
		Servers:      buildJoinSet[serverJoins[Q]](ServerColumns, buildServerJoins),
		Sessions:     buildJoinSet[sessionJoins[Q]](SessionColumns, buildSessionJoins),
		Users:        buildJoinSet[userJoins[Q]](UserColumns, buildUserJoins),
	}
}

type modAs[Q any, C interface{ AliasedAs(string) C }] struct {
	c C
	f func(C) bob.Mod[Q]
}

func (m modAs[Q, C]) Apply(q Q) {
	m.f(m.c).Apply(q)
}

func (m modAs[Q, C]) AliasedAs(alias string) bob.Mod[Q] {
	m.c = m.c.AliasedAs(alias)
	return m
}

func randInt() int64 {
	out := int64(new(maphash.Hash).Sum64())

	if out < 0 {
		return -out % 10000
	}

	return out % 10000
}

// ErrUniqueConstraint captures all unique constraint errors by explicitly leaving `s` empty.
var ErrUniqueConstraint = &UniqueConstraintError{s: ""}

type UniqueConstraintError struct {
	// schema is the schema where the unique constraint is defined.
	schema string
	// table is the name of the table where the unique constraint is defined.
	table string
	// columns are the columns constituting the unique constraint.
	columns []string
	// s is a string uniquely identifying the constraint in the raw error message returned from the database.
	s string
}

func (e *UniqueConstraintError) Error() string {
	return e.s
}

func (e *UniqueConstraintError) Is(target error) bool {
	err, ok := target.(*pgconn.PgError)
	if !ok {
		return false
	}
	return err.Code == "23505" && (e.s == "" || err.ConstraintName == e.s)
}
